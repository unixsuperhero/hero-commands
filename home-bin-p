#!/usr/bin/env ruby

require 'awesome_print'
require 'yaml'

class SubcommandMatcher
  class << self
    def from(hash)
      new(hash)
    end
  end

  attr_accessor :subcommands
  attr_accessor :subcommand_map
  attr_accessor :subcommand_names
  def initialize(hash_or_array)
    @subcommand_map = hash_or_array
    @subcommands = hash_or_array.keys
    @subcommand_names = hash_or_array.keys
  end

  def subcommand_variations
    subcommands.inject({}) do |h,name|
      h.merge( name => name.chars.reverse.inject([]){|a,c| a.map{|tail| c + tail }.push(c) } )
    end
  end

  def uniq_variations
    subcommand_variations.inject({}){|vars,(name,list)|
      duplicate_variations  = (subcommand_names - [name]).flat_map(&subcommand_variations.method(:fetch))
      duplicate_variations -= [name]
      (list - duplicate_variations).each do |variation|
        vars.merge! variation => subcommand_map[name]
      end
      vars
    }
  end

  def match(cmd)
    uniq_variations[cmd]
  end
end



class Subcommandable
  class << self
    attr_accessor :subcommand

    def print_subcommand_list
      puts <<-MESSAGE.lines.map{|l| l.chomp.sub(/^\s{8}/, '') }
        ERROR: Subcommand required.

        Possible subcommands:
          #{subcommand_names.join("\n  ")}
      MESSAGE
    end

    def run(args=argv)
      @args = args || argv
      @subcommand ||= args.shift

      if @subcommand.nil?
        if @no_subcommand.is_a?(Proc)
          @no_subcommand.call
          exit 0
        else
          print_subcommand_list
          exit 1
        end
      end

      @runner ||= subcommand_matcher.match(@subcommand)

      if @runner
        @runner.call
        exit 0
      end

      if @dynamic_subcommand
        @dynamic_subcommand.call
        exit 0
      end

      puts format('Runner/handler not found for the "%s" subcommand', subcommand)
      exit 1
    end

    def args
      argv
    end

    def argv
      @args ||= ARGV.clone
    end

    def subcommand_matcher
      SubcommandMatcher.new subcommands
    end

    def subcommand_names
      @subcommands.keys
    end

    def subcommands
      @subcommands ||= {}
    end

    def fallback_runner
      @fallback_runner ||= Proc.new do
        puts format('No handler for the "%s" subcommand', subcommand.inspect)
        exit 1
      end
    end

    def default_handler(&block)
      @no_subcommand = @dynamic_subcommand = block
    end

    def no_subcommand(&block)
      @no_subcommand = block
    end

    def dynamic_subcommand(&block)
      @dynamic_subcommand = block
    end

    def register_subcommand(name, &block)
      subcommands.merge!( name.to_s => block ).tap{|cmds|
      # @headers_printed ||= []
      #unless @headers_printed.include?(self)
      #  puts
      #  puts format('Class Name: %s', self.name)
      #  puts format('Registered subcommand: %s', name)
      #  puts
      #  puts format('  Subcommand Names:', name)

      #  @headers_printed.push(self)
      #end
      #puts format('    %s', name)
      }
    end
  end
end


class DotHash
  class << self
    def for(file)
      new(file)
    end
  end

  attr_accessor :official_data
  attr_accessor :mapped_data
  def initialize(h)
    @official_data = h.clone
    @mapped_data = h.clone
  end

  def [](key)
    config_data[key]
  end

  def []=(key, val)
    config_data[key] = val
  end

  def save
    IO.write(filename, YAML.dump(config_data))
  end

  def file_exists?
    File.exist?(filename)
  end

  def write_empty_config_if_file_is_missing
    return if file_exists?
    IO.write filename, YAML.dump({})
  end

  def method_missing(key, *args)
    base,operator = key.to_s.split(/(?<=\w)(?=\W*$)/i).push('')
    matchers = 0.upto(operator.length).flat_map{|len|
      m = base + operator.slice(0,len)
      [m, m.to_sym]
    }

    matching_key = config_data.keys.find{|k| matchers.include?(k) }

    # if it's a getter
    if args.count == 0
      config_data[matching_key]

    # if it's a setter and the matched and existing key
    elsif matching_key
      config_data.merge! matching_key => args.first

    # if it's a setter and it's a new key
    else
      config_data[base] = args.first
    end
  end
end



class Git
  class << self
    def current_branch
      `git rev-parse --symbolic-full-name HEAD`.chomp.split(?/,3).last
    end

    def status
      `git status -s`.lines.flat_map{|line|
        line.chomp.sub(/.../,'').split(/\s+->\s+/)
      }.uniq
    end

    def branches
      `git branch`.lines.flat_map{|line|
        line.split(/\s+/).select{|b| b[/\w/] }
      }.uniq
    end

    def branch_parts(branch=current_branch)
      parts = branch.split(?/)
      base = parts.pop
      prefix = parts.join(?/)
      DotHash.new({base: base,
                      has_prefix: parts.count > 0,
                      prefix: parts.join(?/)})
    end

    def branch_base
      branch_parts.base
    end

    def branch_has_prefix?
      branch_parts.has_prefix
    end

    def branch_prefix
      branch_parts.prefix
    end
  end
end

class Heroku
  class << self
    def qa_remote_name(project, branch)
      format('%s-%s', project, branch.gsub(/\W+/, ?-))
    end

    def apps
      app_remotes.values.uniq
    end

    def remotes
      app_remotes.keys
    end

    def app_remotes
      `git remote -v`.lines.map(&:chomp).select{|l|
        l[/heroku/i]
      }.inject({}){|h,remote|
          rem = remote[/^\S+/]
          app = remote[/(?<=[\/:])[^\/]+(?=[.]git)/i]
          h.merge(rem => app)
      }
    end
  end
end

class PathEnv
  class << self
    def env
      ENV['PATH']
    end

    def split
      env.split(/:+/)
    end

    def list
      split.inject([]) do |arr,path|
        next arr unless File.exist?(path)
        arr.include?(path) ? arr : arr.push(path)
      end
    end

    def absolute_paths
      split.inject([]) do |list,path|
        abspath = File.absolute_path(path)
        next list unless File.exist?(abspath)
        list.include?(abspath) ? list : list.push(abspath)
      end
    end

    def all_glob(pattern='')
      format '{%s}/%s', list.join(?,), pattern
    end

    def find(exact_name)
      Dir[all_glob(exact_name)]
    end

    def search(name)
      Dir[all_glob('*%s*' % name)]
    end

    def fuzzy_search(pattern)
      Dir[all_glob('*%s*' % name.chars.join(?*))]
    end
  end
end

class DependencyChecker
  class << self
    def brew(keg_name, display_name=nil)
      matches = PathEnv.find(keg_name) || []
      if matches.count == 0
        install_missing_brew_dependency(keg_name, display_name)
      end
      return (PathEnv.find(keg_name) || []).count > 0
    end

    def install_missing_brew_dependency(keg_name, display_name=nil)
      if (PathEnv.find('brew') || []).count == 0
        puts <<-MESSAGE
  Missing Dependency: #{display_name || keg_name}

  Homebrew is required to install this missing dependency.

  Please visit http://brew.sh for instructions.
        MESSAGE
        return false
      else
        printf <<-MESSAGE
  Missing Dependency: #{display_name || keg_name}

  Would you like to install it (default: y)? [yn]
        MESSAGE

        STDOUT.flush
        answer = STDIN.gets

        if answer == ?y
          install_keg(keg_name)
        end
      end
    end

    def install_keg(keg_name)
      system('brew', 'install', keg_name)
    end
  end
end

class Config
  class << self
    def for(file)
      new(file)
    end
  end

  attr_accessor :filename, :file_contents, :config_data
  def initialize(filename)
    @filename = filename
    write_empty_config_if_file_is_missing

    @file_contents = IO.read(@filename)
    @config_data = YAML.load(@file_contents)
  end

  def [](key)
    config_data[key]
  end

  def []=(key, val)
    config_data[key] = val
  end

  def save
    IO.write(filename, YAML.dump(config_data))
  end

  def file_exists?
    File.exist?(filename)
  end

  def write_empty_config_if_file_is_missing
    return if file_exists?
    IO.write filename, YAML.dump({})
  end

  def method_missing(key, *args)
    base,operator = key.to_s.split(/(?<=\w)(?=\W*$)/i).push('')
    matchers = 0.upto(operator.length).flat_map{|len|
      m = base + operator.slice(0,len)
      [m, m.to_sym]
    }

    matching_key = config_data.keys.find{|k| matchers.include?(k) }

    # if it's a getter
    if args.count == 0
      config_data[matching_key]

    # if it's a setter and the matched and existing key
    elsif matching_key
      config_data.merge! matching_key => args.first

    # if it's a setter and it's a new key
    else
      config_data[base] = args.first
    end
  end
end


class MainCommand < Subcommandable
  dynamic_subcommand{
    ByProject.run(args.unshift(subcommand))
  }

  list_projects = Proc.new{|args|
    Config.for( File.join(ENV['HOME'], 'projects.yml') )['projects'].map{|p|
      p['name']
    }.tap(&method(:puts))
  }

  register_subcommand :all, &list_projects
  register_subcommand :list, &list_projects
  register_subcommand :show, &list_projects
  register_subcommand :print, &list_projects

  register_subcommand :dir do
    projects = Config.for(File.join(ENV['HOME'],'projects.yml'))

    project = projects['projects'].find{|p|
      p['name'] == args.first
    }

    unless project
      puts format('Project "%s" Not Found', args.first)
      exit 1
    end

    printf project['path']
    exit 0
  end

  register_subcommand :add do
    projects = Config.for(File.join(ENV['HOME'],'projects.yml'))

    name,path,other = args
    projects['projects'].push({
      'name' => name,
      'path' => path || Dir.pwd
    })
    projects.save
  end

  register_subcommand :issues do
    Issues.run(args)
  end

  register_subcommand :branch do
    Branches.run(args)
  end

  register_subcommand :feature do
    Features.run(args)
  end

  class ByProject < Subcommandable
    def self.project_file
      File.join(ENV['HOME'], 'projects.yml')
    end

    def self.project_config
      @project_config ||= Config.for(project_file)
    end

    def self.project_matcher
      name_map = project_config.projects.map{|p| [p['name'], p] }.to_h
      @project_matcher = SubcommandMatcher.new(name_map)
    end

    def self.matching_project(name)
      project_matcher.match(name)
    end

    def self.tmux_session_exists?(name)
      `tmux ls`.lines.any?{|l| l[/^#{name}:/] }
    end

    def self.attach_to_tmux_session(name)
      exec("tmux a -t #{name}")
    end

    def self.start_new_tmux_session(proj)
      exec("tmux new -s #{proj['name']} -c #{proj['path']} " + args.join(' '))
    end

    default_handler{
      project_name = subcommand
      proj = matching_project(project_name)
      if proj
        tmux_session_exists?(proj['name']) ?
          attach_to_tmux_session(proj['name']) :
          start_new_tmux_session(proj)
      end
    }
  end

  class Features < Subcommandable
    register_subcommand(:start) {
      if args.first.to_i == 0
        <<-"MESSAGE"

  The next argument after start should be the
  issue number, followed by a few words
  describing it.

        MESSAGE
        exit 1
      end

      # check_for_active_feature
      checkout_development_base_branch
      rebase_branch
      checkout_new_feature_branch
      save_feature_info_in_project_yml
    }

    def self.checkout_development_base_branch
      `git checkout develop`
    end

    def self.rebase_branch
      `git pull --rebase origin develop`
    end

    def self.checkout_new_feature_branch
      `git checkout -b feature/#{args.join(?-)}`
    end

    def self.save_feature_info_in_project_yml
      #config = Config.for('project.local.yml')
      config = Config.for('project.local.yml')
      config.current_issue_id = args.first
      config.current_feature_branch = format('feature/%s', args.join(?-))
      ap config: config,
         config_data: config.config_data,
         bytes_saved: config.save
    end

    register_subcommand(:push) {
      ap feature: :push, args: args
    }

    register_subcommand(:rebase) {
      ap feature: :rebase, args: args
    }

    def self.project_config
      @project_config ||= Config.for('project.yml')
    end

    def self.local_config
      @local_config ||= Config.for('project.local.yml')
    end

    def self.heroku_app_data(remote:, branch:, issue:)
      {
        'remote_name' => remote,
        'branch' => branch,
        'issue_number' => issue.to_i,
      }
    end

    register_subcommand(:test) {
      ap feature: :test, args: args
      remote_name = Heroku.qa_remote_name(project_config.name, local_config.current_feature_branch)
      feature_apps = local_config.feature_apps || []
      app = heroku_app_data(remote: remote_name, branch: local_config.current_feature_branch, issue: local_config.current_feature_id)
      branch = local_config.current_feature_branch

      app_fork = remote_name[0,30]

      if Heroku.apps.include?(app_fork)
        system *%W[ heroku apps:destroy --app #{app_fork} --confirm #{app_fork} ]
        #system *%W[ git push #{app_fork} #{branch}:master ]
        #system *%W[ heroku run rake db:migrate -r #{app_fork} ]
      end


      if system *%W[heroku fork --from copley-staging --to #{app_fork}]
          unless feature_apps.include?(app)
            feature_apps.unshift(app)
          local_config.feature_apps = feature_apps || []
            local_config.save
          end
        system *%W[ git remote add #{app_fork} https://git.heroku.com/#{app_fork}.git]
        system *%W[ git push #{app_fork} #{branch}:master ]
        system *%W[ heroku run rake db:migrate -r #{app_fork} ]
      end
    }

    register_subcommand(:finish) {
      ap feature: :finish, args: args


      remote_name = Heroku.qa_remote_name(project_config.name, local_config.current_feature_branch)
      feature_apps = local_config.feature_apps || []
      app = heroku_app_data(remote: remote_name, branch: local_config.current_feature_branch, issue: local_config.current_feature_id)
      branch = local_config.current_feature_branch

      app_fork = remote_name[0,30]

      system *%W[ git branch backup/#{Git.branch_base} #{branch} ]
      system *%W[ git checkout develop ]
      system *%W[ git pull --rebase -p origin develop ]
      system *%W[ git checkout #{branch} ]
      system *%W[ git rebase -p develop ]
      system *%W[ git checkout develop ]
      system *%W[ git merge --no-ff #{branch} ]
    }

    register_subcommand(:pause) {
      ap feature: :pause, args: args
    }
  end

  class Branches < Subcommandable
    register_subcommand(:link) {
      puts format('called branch:link with %s and %s', subcommand, args[0])
    }

    register_subcommand(:list) {
      puts `git branch`.lines.map{|line|
        line.chomp.sub(/^../,'')
      }.sort.uniq
    }

    default_handler {
      printf Git.current_branch
      exit 0
    }
  end

  class Issues < Subcommandable
    register_subcommand(:list) {
      system('ghi', 'list')
    }

    default_handler {
      system('ghi', 'list')
    }
  end
end

MainCommand.run


#!/usr/bin/env ruby

require 'awesome_print'
require 'pry'
require 'yaml'
require 'shell'

class Hash
  class << self
    def endless_proc
      Proc.new do |h,k|
        h[k] = Hash.new(&endless_proc)
      end
    end

    def endless
      Hash.new(&endless_proc)
    end

    def make_endless(hash)
      hash.tap do |h|
        h.default_proc = endless_proc
        h.each do |k,v|
          next unless v.is_a?(Hash)
          h[k] = make_endless(v)
        end
      end
    end

    def with_default(default_value)
      Hash.new{|h,k| h[k] = default_value.clone }
    end
  end

  def select_keys(*keys)
    dup.select{|k,v| keys.include?(k) }
  end
  alias_method :pluck, :select_keys
  alias_method :slice, :select_keys
  alias_method :subset, :select_keys

  def deep_merge(other_hash, &block)
    dup.deep_merge!(other_hash, &block)
  end

  def deep_merge!(other_hash, &block)
    other_hash.each_pair do |current_key, other_value|
      this_value = self[current_key]

      self[current_key] = if this_value.is_a?(Hash) && other_value.is_a?(Hash)
        this_value.deep_merge(other_value, &block)
      else
        if block_given? && key?(current_key)
          block.call(current_key, this_value, other_value)
        else
          other_value
        end
      end
    end

    self
  end
end


# vim: ft=ruby
require 'yaml'



class Config
  attr_accessor :file, :data_path
  attr_accessor :before_save_hooks, :after_save_hooks
  attr_accessor :before_read_hooks, :after_read_hooks

  def initialize(file, *data_path)
    @file, @data_path = file, data_path
    @before_read_hooks = []
    @after_read_hooks = []
    @before_save_hooks = []
    @after_save_hooks = []
  end

  def clear_before_read_hooks!
    @before_read_hooks = []
  end

  def clear_after_read_hooks!
    @after_read_hooks = []
  end

  def clear_before_save_hooks!
    @before_save_hooks = []
  end

  def clear_after_save_hooks!
    @after_save_hooks = []
  end

  def before_read(&block)
    return unless block_given?
    @before_read_hooks.push(block)
  end

  def after_read(&block)
    return unless block_given?
    @after_read_hooks.push(block)
  end

  def before_save(&block)
    return unless block_given?
    @before_save_hooks.push(block)
  end

  def after_save(&block)
    return unless block_given?
    @after_save_hooks.push(block)
  end

  def yaml_file
    @file #File.join(Dir.home, 'rippers.yml')
  end

  # def yaml_outfile
  #   File.join(Dir.home, 'rippers.yml')
  # end

  def yaml_data
    IO.read yaml_file
  end

  def read!
    before_read_hooks.map{|hook| hook.call(self) }
    @data = YAML.load(yaml_data) || {}
    after_read_hooks.map{|hook| hook.call(self) }
    Hash.make_endless(@data)
  end

  def read
    @data || read!
  end

  def save
    before_save_hooks.map{|hook| hook.call(self) }
    IO.write yaml_file, YAML.dump(@data)
    after_save_hooks.map{|hook| hook.call(self) }
    read!
  end

  def write
    save
  end

  def update(vals={})
    data.clear.merge!(vals)
  end

  def merge(vals={})
    data.deep_merge!(stringify_keys vals)
  end

  def stringify_keys(vals={})
    vals.tap do |strs|
      vals.keys.select{|k|
        k.is_a?(Symbol) && not(k.is_a?(String))
      }.each do |k|
        strs.merge!(k.to_s => strs.delete(k))
      end
    end
  end

  def all_data
    read
  end

  def data
    return all_data if data_path == []
    data_path.inject(all_data){|result,key|
      # result.merge!(key => result.fetch(key, {}))[key]
      result[key]
    }
  end
end


# vim: ft=ruby

class SubcommandMatcher
  class << self
    def from(hash)
      new(hash)
    end

    def list_for(str)
      str.chars.inject([]) do |arr,c|
        arr.push((arr.last || '') + c)
      end
    end
  end

  attr_accessor :subcommands
  attr_accessor :subcommand_map
  attr_accessor :subcommand_names
  def initialize(hash_or_array)
    @subcommand_map = hash_or_array
    @subcommands = hash_or_array.keys
    @subcommand_names = hash_or_array.keys
  end

  def list_for(str)
    self.class.list_for(str)
  end

  def name_map
    deletes = []
    subcommand_map.inject({}){|h,(k,v)|
      h.tap do |new_map|
        list_for(k).each do |e|
          if h.has_key?(e)
            deletes.push(e) if h[e] != v
          else
            new_map.merge!(e => k)
          end
        end
      end
    }.tap{|uniq_map|
      deletes.each{|k| uniq_map.delete(k) }
    }.merge(Hash[ subcommand_names.zip(subcommand_names) ])
  end

  def uniqs
    deletes = []
    subcommand_map.inject({}){|h,(k,v)|
      h.tap do |new_map|
        list_for(k).each do |e|
          if h.has_key?(e)
            deletes.push(e) if h[e] != v
          else
            new_map.merge!(e => v)
          end
        end
      end
    }.tap{|uniq_map|
      deletes.each{|k| uniq_map.delete(k) }
    }.merge(subcommand_map)
  end

  def subcommand_variations
    subcommands.inject({}) do |h,name|
      h.merge( name => name.chars.reverse.inject([]){|a,c| a.map{|tail| c + tail }.push(c) } )
    end
  end

  def uniq_variations
    subcommand_variations.inject({}){|vars,(name,list)|
      duplicate_variations  = (subcommand_names - [name]).flat_map(&subcommand_variations.method(:fetch))
      duplicate_variations -= [name]
      (list - duplicate_variations).each do |variation|
        vars.merge! variation => subcommand_map[name]
      end
      vars
    }
  end

  def shortest_variations
    sorted_uniqs = uniqs.keys.sort_by(&:length)
    subcommand_names.inject({}){|h,name|
      h.merge(
        name => sorted_uniqs.find{|uniq_name|
          next false if subcommand_names.include?(uniq_name) && name != uniq_name
          name.start_with?(uniq_name)
        }
      )
    }
  end

  def simple_syntax_for(full,abbr)
    return abbr if abbr == full
    right = full.slice(abbr.length, full.length)
    format('%s[%s]', abbr, right)
  end

  def complex_syntax_for(full,abbr)
    left,right = full.slice(0, abbr.length), full.slice(abbr.length, full.length)
    return right.chars.inject(abbr.dup){|syn,c| syn.dup.concat(?[.dup).concat(c.dup) }.concat(?].dup * right.dup.length)
    format('%s%s%s', abbr,
                     right.chars.map{|c| ?[ + c }.join,
                     ?] * right.length)
  end

  def syntax_formats
    shortest_variations.map{|full,abbr|
      # optional = full.slice(abbr.length, full.length)
      {
        full => {
          simple: simple_syntax_for(full, abbr), # format('%s[%s]', abbr, optional),
          complex: complex_syntax_for(full, abbr), # format('%s%s', abbr, optional.chars.map{|c| ?[ + c }.push(?] * optional.length).join),
        }
      }
    }.inject(:merge)
  end

  def syntax(type=:simple)
    type = :simple unless type.respond_to?(:to_sym) && %i[ simple complex ].include?(type.to_sym)
    syntax_formats.map{|k,h| { k => h[type.to_sym] } }.inject(:merge)
    # shortest_variations.map{|full,abbr|
    #   optional = full.slice(abbr.length, full.length)
    #   { full => format('%s[%s]', abbr, optional) }
    # }.inject(:merge)
  end
  alias_method :print_format, :syntax

  def match_name(partial)
    name_map[partial]
  end

  def match(cmd)
    uniqs[cmd]
  end
end


module LetHelper
  def self.let(name, &block)
    define_method(name, &block)
  end
end

module ShellCommandable
  def self.included(base)
    base.extend(ClassMethods)
    base.const_set(:BINDING, base.instance_eval{ binding })
  end

  module ClassMethods
    attr_accessor :subcommand

    def self.clet(name, &block)
      define_method(name, &block)
    end

    def error_exit(msg=nil, &block)
      puts format('ERROR: %s', msg) if msg

      block.call if block_given?

      exit 1
    end

    def print_subcommand_list
      puts <<-MESSAGE.lines.map{|l| l.chomp.sub(/^\s{8}/, '') }
        ERROR: Subcommand required.

        Possible subcommands:
          #{subcommand_matcher.syntax.values.join("\n  ")}
      MESSAGE
    end

    def run_with_hooks(&block)
      ap(binding: BINDING, reciever: BINDING.reciever, methods: BINDING.receiver.methods - Class.methods)
      @before_hook.call if @before_hook
      block.call
      @after_hook.call if @after_hook
    end

    def run(args=argv)
      @args = args || argv
      @subcommand ||= args.shift

      if @subcommand.nil?
        if @no_subcommand.is_a?(Proc)
          run_with_hooks{ @no_subcommand.call }
          exit 0
        else
          print_subcommand_list
          exit 1
        end
      end

      @runner ||= subcommand_matcher.match(@subcommand)

      if @runner
        run_with_hooks{ @runner.call }
        exit 0
      end

      if @dynamic_subcommand
        run_with_hooks{ @dynamic_subcommand.call }
        exit 0
      end

      puts format('Runner/handler not found for the "%s" subcommand', subcommand)
      exit 1
    end

    def args
      argv
    end

    def argv
      @args ||= ARGV.clone
    end

    def subcommand_matcher
      SubcommandMatcher.new subcommands
    end

    def subcommand_names
      @subcommands.keys
    end

    def subcommands
      @subcommands ||= {}
    end

    def fallback_runner
      @fallback_runner ||= Proc.new do
        puts <<-MESSAGE.lines.map{|l| l.chomp.sub(/^\s{10}/, '') }
          No handler for the "#{subcommand.inspect}" subcommand.

          These are the possible subcommands:
            #{subcommand_matcher.syntax.values.join("\n  ")}
        MESSAGE
        exit 1
      end
    end

    def before(&block)
      @before_hook = block
    end

    def after(&block)
      @after_hook = block
    end

    def default_handler(&block)
      @no_subcommand = @dynamic_subcommand = block
    end

    def no_subcommand(&block)
      @no_subcommand = block
    end

    def dynamic_subcommand(&block)
      @dynamic_subcommand = block
    end

    def register_subcommand(*names, &block)
      names.each{|name| subcommands.merge!( name.to_s => block ) }
    end

    def load_subcommands_by_prefix(prefix)
      Dir[File.join(Dir.home, 'subcommands', format('%s-*', prefix))].each do |subcmd|
        load subcmd
      end
    end
  end
end

class Subcommandable
  class << self
    attr_accessor :subcommand

    def inherited(base)
      ap(inherited_base: base, inherited_class: base.class)
      base.extend LetHelper
    end

    def error_exit(msg=nil, &block)
      puts format('ERROR: %s', msg) if msg

      block.call if block_given?

      exit 1
    end

    def let(attr_name, &block)
      return unless block_given?
      attr_name = attr_name.to_sym unless attr_name.is_a?(Symbol)
      define_singleton_method(attr_name, block)
    end

    def print_subcommand_list
      puts <<-MESSAGE.lines.map{|l| l.chomp.sub(/^\s{8}/, '') }
        ERROR: Subcommand required.

        Possible subcommands:
          #{subcommand_matcher.syntax.values.join("\n  ")}
      MESSAGE
    end

    def run_with_hooks(&block)
      @before_hook.call if @before_hook
      block.call
      @after_hook.call if @after_hook
    end

    def run(args=argv)
      @args = args || argv
      @subcommand ||= args.shift

      if @subcommand.nil?
        if @no_subcommand.is_a?(Proc)
          run_with_hooks{ @no_subcommand.call }
          exit 0
        else
          print_subcommand_list
          exit 1
        end
      end

      @runner ||= subcommand_matcher.match(@subcommand)

      if @runner
        run_with_hooks{ @runner.call }
        exit 0
      end

      if @dynamic_subcommand
        run_with_hooks{ @dynamic_subcommand.call }
        exit 0
      end

      puts format('Runner/handler not found for the "%s" subcommand', subcommand)
      exit 1
    end

    def args
      argv
    end

    def argv
      @args ||= ARGV.clone
    end

    def subcommand_matcher
      SubcommandMatcher.new subcommands
    end

    def subcommand_names
      @subcommands.keys
    end

    def subcommands
      @subcommands ||= {}
    end

    def fallback_runner
      @fallback_runner ||= Proc.new do
        puts <<-MESSAGE.lines.map{|l| l.chomp.sub(/^\s{10}/, '') }
          No handler for the "#{subcommand.inspect}" subcommand.

          These are the possible subcommands:
            #{subcommand_matcher.syntax.values.join("\n  ")}
        MESSAGE
        exit 1
      end
    end

    def before(&block)
      @before_hook = block
    end

    def after(&block)
      @after_hook = block
    end

    def default_handler(&block)
      @no_subcommand = @dynamic_subcommand = block
    end

    def no_subcommand(&block)
      @no_subcommand = block
    end

    def dynamic_subcommand(&block)
      @dynamic_subcommand = block
    end

    def register_subcommand(*names, &block)
      names.each{|name| subcommands.merge!( name.to_s => block ) }
    end

    def load_subcommands_by_prefix(prefix)
      Dir[File.join(Dir.home, 'subcommands', format('%s-*', prefix))].each do |subcmd|
        load subcmd
      end
    end
  end
end


# vim: ft=ruby

class PathEnv
  class << self
    def env
      ENV['PATH']
    end

    def split
      env.split(/:+/)
    end

    def list
      split.inject([]) do |arr,path|
        next arr unless File.exist?(path)
        arr.include?(path) ? arr : arr.push(path)
      end
    end

    def absolute_paths
      split.inject([]) do |list,path|
        abspath = File.absolute_path(path)
        next list unless File.exist?(abspath)
        list.include?(abspath) ? list : list.push(abspath)
      end
    end

    def all_glob(pattern='')
      format '{%s}/%s', list.join(?,), pattern
    end

    def find(exact_name)
      Dir[all_glob(exact_name)]
    end

    def search(name)
      Dir[all_glob('*%s*' % name)]
    end

    def fuzzy_search(pattern)
      Dir[all_glob('*%s*' % name.chars.join(?*))]
    end
  end
end


# vim: ft=ruby

class NameMatcher
  class << self
    def from(hash)
      new(hash)
    end

    def list_for(str)
      str.chars.inject([]) do |arr,c|
        arr.push((arr.last || '') + c)
      end
    end
  end

  attr_accessor :subcommands
  attr_accessor :subcommand_map
  attr_accessor :subcommand_names
  def initialize(hash_or_array)
    @subcommand_map = hash_or_array
    @subcommands = hash_or_array.keys
    @subcommand_names = hash_or_array.keys
  end

  def list_for(str)
    self.class.list_for(str)
  end

  def name_map
    deletes = []
    subcommand_map.inject({}){|h,(k,v)|
      h.tap do |new_map|
        list_for(k).each do |e|
          if h.has_key?(e)
            deletes.push(e) if h[e] != v
          else
            new_map.merge!(e => k)
          end
        end
      end
    }.tap{|uniq_map|
      deletes.each{|k| uniq_map.delete(k) }
    }.merge(Hash[ subcommand_names.zip(subcommand_names) ])
  end

  def uniqs_by_name
    deletes = []
    subcommand_map.inject({}){|h,(k,v)|
      h.tap do |new_map|
        list_for(k).each do |e|
          if h.has_key?(e)
            deletes.push(e) if subcommand_map[h[e]] != subcommand_map[k]
          else
            new_map.merge!(e => k)
          end
        end
      end
    }.tap{|uniq_map|
      deletes.each{|k| uniq_map.delete(k) }
    }.merge(Hash[subcommand_names.zip(subcommand_names)])
  end

  def uniqs
    deletes = []
    subcommand_map.inject({}){|h,(k,v)|
      h.tap do |new_map|
        list_for(k).each do |e|
          if h.has_key?(e)
            deletes.push(e) if h[e] != v
          else
            new_map.merge!(e => v)
          end
        end
      end
    }.tap{|uniq_map|
      deletes.each{|k| uniq_map.delete(k) }
    }.merge(subcommand_map)
  end

  def subcommand_variations
    subcommands.inject({}) do |h,name|
      h.merge( name => name.chars.reverse.inject([]){|a,c| a.map{|tail| c + tail }.push(c) } )
    end
  end

  def uniq_variations
    subcommand_variations.inject({}){|vars,(name,list)|
      duplicate_variations  = (subcommand_names - [name]).flat_map(&subcommand_variations.method(:fetch))
      duplicate_variations -= [name]
      (list - duplicate_variations).each do |variation|
        vars.merge! variation => subcommand_map[name]
      end
      vars
    }
  end

  def shortest_variations
    sorted_uniqs = uniqs.keys.sort_by(&:length)
    subcommand_names.inject({}){|h,name|
      h.merge(
        name => sorted_uniqs.find{|uniq_name|
          next false if subcommand_names.include?(uniq_name) && name != uniq_name
          name.start_with?(uniq_name)
        }
      )
    }
  end

  def simple_syntax_for(full,abbr)
    return abbr if abbr == full
    right = full.slice(abbr.length, full.length)
    format('%s[%s]', abbr, right)
  end

  def complex_syntax_for(full,abbr)
    left,right = full.slice(0, abbr.length), full.slice(abbr.length, full.length)
    return right.chars.inject(abbr.dup){|syn,c| syn.dup.concat(?[.dup).concat(c.dup) }.concat(?].dup * right.dup.length)
    format('%s%s%s', abbr,
                     right.chars.map{|c| ?[ + c }.join,
                     ?] * right.length)
  end

  def syntax_formats
    shortest_variations.map{|full,abbr|
      # optional = full.slice(abbr.length, full.length)
      {
        full => {
          simple: simple_syntax_for(full, abbr), # format('%s[%s]', abbr, optional),
          complex: complex_syntax_for(full, abbr), # format('%s%s', abbr, optional.chars.map{|c| ?[ + c }.push(?] * optional.length).join),
        }
      }
    }.inject(:merge)
  end

  def syntax(type=:simple)
    type = :simple unless type.respond_to?(:to_sym) && %i[ simple complex ].include?(type.to_sym)
    syntax_formats.map{|k,h| { k => h[type.to_sym] } }.inject(:merge)
    # shortest_variations.map{|full,abbr|
    #   optional = full.slice(abbr.length, full.length)
    #   { full => format('%s[%s]', abbr, optional) }
    # }.inject(:merge)
  end
  alias_method :print_format, :syntax

  def match_name(partial)
    name_map[partial]
  end

  def match(cmd)
    uniqs[cmd]
  end

  def match_with_data(partial)
    return unless uniqs.has_key?(partial)
    {}.tap{|data|
      full_name = match_name(partial)
      data.merge!(
        name: full_name,
        data: uniqs[partial],
        syntax: syntax[full_name],
        # syntax
        # array of uniq matches
      )
    }
  end
end

class Tmux
  class << self
    def sessions
      `tmux ls`.lines.select{|l| l[/^[^:]+:\s+\d/i] }.map{|l| l[/^([^:]+)(?=:\s+\d+)/i] }
    end

    def session_exists?(name)
      sessions.include?(name)
    end

    def attach_to_session(name)
      exec("tmux a -t #{name}")
    end

    def new_session(name, path=Dir.pwd, *args)
      exec("tmux new -s #{name} -c #{path} " + args.join(' '))
    end
  end
end


# vim: ft=ruby


class ProjectHelper
  class << self
    def project_for(partial)
      partial = partial[1..-1] if partial[0] == ?@
      project_matcher.match_with_data(partial)
    end

    def config
      Config.new(yaml_file, 'projects').tap{|configuration|
        configuration.after_read do |this|
          this.data.map{|k,v|
            expanded_path = File.expand_path(v)
            dug = this.instance_variable_get(:@data)
            dug = dug.dig(*this.data_path)
            dug.merge!(k => expanded_path)
          }
        end

        configuration.before_save do |this|
          this.data.map{|k,v|
            relative_path = v.sub(%r{^(/(?:Users|home)/[^/]+)(/?)}, '~\2/').sub(%r{//+}, ?/)
            dug = this.instance_variable_get(:@data)
            dug = dug.dig(*this.data_path)
            dug.merge!(k => relative_path)
          }
        end
        configuration.read!
      }
    end

    def project_matcher
      NameMatcher.from(config.data)
    end

    def yaml_file
      File.join(Dir.home, 'projects.yml')
    end

    def is_project?(partial)
      full_name = project_matcher.match_name(partial)
    end

    def projects
      config.data.keys
    end

    def dir_for(project_partial)
      project_matcher.match(project_partial)
    end

    def dirs
      config.data.values
    end

    def tmux_session_for_project(project_name)
      name = project_matcher.match_name(project_name)
      path = project_matcher.match(project_name)

      error_exit('No project found matching "%s"...' % project_name) unless name

      puts
      puts format('Project Name: %s', name)
      puts format('Project Path: %s', path)
      puts

      if Tmux.session_exists?(name)
        Tmux.attach_to_session(name)
      else
        Tmux.new_session(name, path)
      end
    end
  end
end


class HeroHelper
  class << self
    def string_to_underscores(str)
      str.split(/[\s_-]+/).flat_map{|part|
        part.split(/(?<=[a-z])(?=[A-Z])/)
      }.flat_map{|part|
        part.split(/(?<=[A-Z])(?=[A-Z][a-z])/)
      }.map(&:downcase).join(?_)
    end

    def string_to_classname(str)
      string = str.to_s
      string = string.sub(/^[a-z\d]*/) { |match| match.capitalize }
      string.gsub!(/(?:_|(\/))([a-z\d]*)/i) { "#{$1}#{$2.capitalize}" }
      string.gsub!('/'.freeze, '::'.freeze)
      string
    end

    def edit_in_editor(*args)
      exec cmd_from(args.unshift(editor))
    end

    def cmd_from(*args)
      parts = args.flatten

      if parts.first[/\w\s+--?\w/i]
        cmd_with_options = parts.shift
        start_cmd = Shellwords.split(cmd_with_options)
        parts = start_cmd + parts
      end

      parts.shelljoin
    end

    def system_from(*args)
      system cmd_from(*args)
    end

    def exec_from(*args)
      exec cmd_from(*args)
    end

    def output_from(*args)
      r,w = IO.pipe
      system cmd_from(*args, out: w)
      w.close
      r.read.tap{|output| r.close }
    end

    class PipeCommand
      attr_accessor :cmd, :reader, :writer
      def initialize(cmd)
        @cmd = cmd
      end

      def run
        system(cmd,
          {}.tap{|opts|
            opts.merge!(in: reader) if reader
            opts.merge!(out: writer) if writer
          }
        ).tap{
          reader.close if reader
          writer.close if writer
        }
      end
    end

    def pipe_cmds(*cmds)
      pcmds = cmds.flatten.map(&PipeCommand.method(:new))
      return '' if cmds.empty?
      pcmds.each_cons(2).to_a.each{|b,a|
        a.reader, b.writer = IO.pipe
      }
      final_reader, pcmds.last.writer = IO.pipe
      pcmds.each(&:run)
      final_reader.read{ final_reader.close }
    end

    def mkdirs_for_file(file)
      return false if File.exist?(file)
      mkdirs File.dirname(file)
    end

    def mkdirs(dir_only)
      return false if File.exist?(dir_only)
      system cmd_from('mkdir', '-pv', dir_only)
    end

    def editor
      ENV.fetch('EDITOR', 'vim')
    end

    def everything_in_dir(dir)
      Dir[File.join(dir, '**/*')]
    end

    def files_in_dir(dir)
      everything_in_dir(dir).select(&File.method(:file?))
    end

    def folders_in_dir(dir)
      everything_in_dir(dir).select(&File.method(:directory?))
    end

    def run_inside_dir(dir, &block)
      return false unless block_given?
      pwd = Dir.pwd.tap{
        Dir.chdir(dir)
      }

      block.call.tap{
        Dir.chdir(pwd)
      }
    end
  end
end


# vim: ft=ruby


class MainCommand
  include ShellCommandable

  def self.run(args=argv)
    if args.first && args.first[0] == ?@
      project_data = ProjectHelper.project_for(args.first)
      project_context.merge!(project_data) if project_data
      args.shift
    end
    super
  end

  def self.project_context
    @project_context ||= {}
  end

  def self.editor
    ENV['EDITOR'] || 'vim'
  end

  register_subcommand(:edit) {
    files = args.flat_map{|arg| PathEnv.search(arg) }

    HeroHelper.edit_in_editor(files)
    # system(files.unshift(editor).shelljoin)
  }

  register_subcommand(:pry) {
    puts 'Entering a pry session...'
    binding.pry
    puts 'done'
  }

  register_subcommand(:z) { # testing the exit codes for diff
    output = `diff /tmp/diff-test-a /tmp/diff-test-b &>/dev/null`
    ap output: output, sucessful: $?.success?

    output = `diff /tmp/diff-test-a /tmp/diff-test-c &>/dev/null`
    ap output: output, sucessful: $?.success?
    exit 0
  }

  register_subcommand(:fix) {
    unless Object.const_defined?(:FixSubcommand)
      found = PathEnv.find('new_h-fix')
      load found.first
    end

    if Object.const_defined?(:FixSubcommand)
      FixSubcommand.run(args)
      exit 0
    end

    raise Exception, 'Unable to load FixSubcommand'
  }

  # register_subcommand(:git) {
  #   GitSubcommand.run(args)
  # }


end

MainCommand.load_subcommands_by_prefix('h')
MainCommand.run



# vim: ft=ruby

#!/usr/bin/env ruby

require 'awesome_print'
require 'pry'
require 'yaml'
require 'shell'

<%=
  inject_files(
    'src/lib/hash_ext.rb.erb',
    'src/lib/config.rb.erb',
    'src/lib/value.rb.erb',
    'src/lib/name_matcher.rb.erb',
    'src/lib/shell_commandable.rb.erb',
    'src/lib/path_env.rb.erb',
    'src/lib/project_helper.rb.erb',
    'src/lib/list_filter.rb.erb',
    'src/lib/hero_helper.rb.erb'
  )
%>

class MainCommand
  include ShellCommandable

  def self.run(args=argv)
    if args.first && args.first[0] == ?@
      @project_context = ProjectHelper.project_for(args.first)
      args.shift
    end

    modified_with_special = special_modifier_args.keys.map{|arg|
      index = args.index(arg)
      ap(arg: arg, index: index)
      next if index.nil?
      left = args[0..(index - 1)]
      right = args[(index + 1)..-1]
      ap(arg: arg,
         args_before: args,
         left: left,
         right: right)
      args = left
      ap(args_after: args)
      [arg, right]
    }.compact.to_h

    ap(modded_with_special: modified_with_special)

    modified_with = args.reverse.take_while{|arg|
      modifier_args.keys.include?(arg)
    }
    modified_with.length.times{ args.pop }

    if project_context?
      HeroHelper.run_inside_dir(project_dir){
        returned = super
        ap(returned: returned)
        modified_with_special.each{|arg,cmd|
          ap(inside: 'special modifier handler - WITH project context', arg: arg, cmd: cmd)
          special_modifier_args[arg].call(returned, cmd)
        }

        modified_with.each{|arg|
          modifier_args[arg].call(returned)
        }
      }
    else
      returned = super
      ap(returned: returned)
      modified_with_special.each{|arg,cmd|
        ap(inside: 'special modifier handler - no project context', arg: arg, cmd: cmd)
        special_modifier_args[arg].call(returned, cmd)
      }

      modified_with.each{|arg|
        modifier_args[arg].call(returned)
      }
    end
  end

  def self.modifier_args
    {
      '@vim' => Proc.new{|returned|
        HeroHelper.edit_in_editor *returned.flatten
      },
      '@capture' => Proc.new{|returned|
        tempfile = Tempfile.create('hero')

        case returned
        when String
          IO.write(tempfile.path, returned)
          HeroHelper.edit_in_editor(tempfile.path)
        when Array
          IO.write(tempfile.path, returned.join("\n"))
          HeroHelper.edit_in_editor(tempfile.path)
        else
          puts format('Not sure how to capture a %s...', returned.class)
        end

        tempfile.delete
        tempfile.close
      }
    }
  end

  def self.special_modifier_args
    {
      '@each' => Proc.new{|returned,cmd|
        break unless returned.is_a?(Array)
        if not cmd.any?{|arg| arg[/(?<!\\)%s/i] }
          cmd.push '%s'
        end
        gsub = %r{(?<!\\)%s}i
        cmd = cmd.map{|arg| arg.gsub(gsub, '%<arg>s') }
        returned.map{|arg|
          current_command = cmd.map{|item| format(item, arg: arg.shellescape) }
          system(*current_command)
        }
      },
      '@all' => Proc.new{|returned,cmd|
        break unless returned.is_a?(Array)
        if not cmd.any?{|arg| arg[/(?<!\\)%s/i] }
          cmd.push '%s'
        end
        gsub = %r{(?<!\\)%s}i
        cmd = cmd.map{|arg| arg.gsub(gsub, '%<list>s') }
        current_command = cmd.map{|item| format(item, list: returned.map(&:shellescape).join(' ')) }
        system(*current_command)
      },
    }
  end

  def self.project_context?
    ! @project_context.nil?
  end

  def self.project_dir
    return unless project_context?
    project_context.data
  end

  def self.project_context
    @project_context
  end

  def self.editor
    ENV['EDITOR'] || 'vim'
  end

  register_subcommand(:edit) {
    files = args.flat_map{|arg| PathEnv.search(arg) }

    HeroHelper.edit_in_editor(files)
  }

  register_subcommand(:google) {
    query = args.join(" ")
    encoded_query = URI.encode(query)
    url = format('http://google.com/search?q=%s', encoded_query)
    HeroHelper.exec_from('open', url)
  }

  register_subcommand(:pry) {
    puts 'Entering a pry session...'
    binding.pry
    puts 'done'
  }

  register_subcommand(:run) {
    error_exit('Nothing to run...pass in cmd as arguments.') if args.empty?
    puts HeroHelper.exec_from(*args)
  }

  register_subcommand(:fix) {
    unless Object.const_defined?(:FixSubcommand)
      found = PathEnv.find('new_h-fix')
      load found.first
    end

    if Object.const_defined?(:FixSubcommand)
      FixSubcommand.run(args)
      exit 0
    end

    raise Exception, 'Unable to load FixSubcommand'
  }

end

MainCommand.load_subcommands_by_prefix('h')

MainCommand.run unless ENV.has_key?('H_SKIP_RUN')


# vim: ft=ruby
